<!DOCTYPE html>
<html>
<head>
    <title>Monitoramento de Redes com Zabbix/Grafana</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-streaming"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@2.0.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.0.0"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .chart-container {
            height: 300px;
            margin-bottom: 20px;
        }
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }
        .network-card {
            padding: 10px;
            border-radius: 5px;
            border-left: 5px solid #ccc;
        }
        .online {
            border-left-color: #4CAF50;
            background-color: #e8f5e9;
        }
        .offline {
            border-left-color: #f44336;
            background-color: #ffebee;
        }
        .intruso {
            color: #f44336;
            font-weight: bold;
        }
        .bloqueado {
            color: #ff9800;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
        }
        .intrusion-alert {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ffebee;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            border-left: 5px solid #f44336;
        }
    </style>
</head>
<body>
<h1>Monitoramento de Redes Integrado</h1>

<div class="dashboard">
    <!-- Painel de Status -->
    <div class="panel">
        <h2>Status das Redes</h2>
        <div id="network-status" class="status-grid">
            <!-- Dinamicamente preenchido por JavaScript -->
        </div>
    </div>

    <!-- Painel de Intrusos -->
    <div class="panel">
        <h2>Intrusos Detectados</h2>
        <table id="intrusos-table">
            <thead>
                <tr>
                    <th>IP</th>
                    <th>MAC</th>
                    <th>Primeira Detecção</th>
                    <th>Tentativas</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
                <!-- Dinamicamente preenchido por JavaScript -->
            </tbody>
        </table>
    </div>

    <!-- Gráfico de Latência (Zabbix) -->
    <div class="panel">
        <h2>Latência em Tempo Real (Zabbix)</h2>
        <div class="chart-container">
            <canvas id="zabbixLatencyChart"></canvas>
        </div>
    </div>

    <!-- Gráfico de Tráfego (Grafana) -->
    <div class="panel">
        <h2>Tráfego de Rede (Grafana)</h2>
        <div class="chart-container">
            <canvas id="grafanaTrafficChart"></canvas>
        </div>
    </div>

    <!-- Gráfico de Disponibilidade -->
    <div class="panel">
        <h2>Disponibilidade das Redes</h2>
        <div class="chart-container">
            <canvas id="availabilityChart"></canvas>
        </div>
    </div>

    <!-- Gráfico de Portas Abertas -->
    <div class="panel">
        <h2>Portas Abertas</h2>
        <div class="chart-container">
            <canvas id="portsChart"></canvas>
        </div>
    </div>
</div>

<script>
    // Configuração global do Chart.js
    Chart.defaults.font.family = 'Arial';
    Chart.defaults.font.size = 12;
    Chart.defaults.color = '#666';

    class NetworkMonitor {
        constructor() {
            this.charts = {};
            this.networkData = {};
            this.initCharts();
            this.initWebSocket();
            this.setupZabbixGrafanaIntegration();
        }

        initCharts() {
            // Gráfico de Latência (Zabbix)
            this.charts.zabbixLatency = new Chart(
                document.getElementById('zabbixLatencyChart'),
                this.getZabbixLatencyConfig()
            );

            // Gráfico de Tráfego (Grafana)
            this.charts.grafanaTraffic = new Chart(
                document.getElementById('grafanaTrafficChart'),
                this.getGrafanaTrafficConfig()
            );

            // Gráfico de Disponibilidade
            this.charts.availability = new Chart(
                document.getElementById('availabilityChart'),
                this.getAvailabilityConfig()
            );

            // Gráfico de Portas Abertas
            this.charts.ports = new Chart(
                document.getElementById('portsChart'),
                this.getPortsConfig()
            );
        }

        getZabbixLatencyConfig() {
            return {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Latência das Redes (ms)'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            type: 'realtime',
                            realtime: {
                                duration: 300000, // 5 minutos
                                refresh: 1000,
                                delay: 2000,
                                onRefresh: chart => {
                                    // Esta função será chamada periodicamente
                                    // Você pode buscar dados do Zabbix aqui
                                }
                            },
                            title: {
                                display: true,
                                text: 'Tempo'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Latência (ms)'
                            },
                            min: 0
                        }
                    }
                }
            };
        }

        getGrafanaTrafficConfig() {
            return {
                type: 'bar',
                data: {
                    labels: ['Entrada', 'Saída'],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Tráfego de Rede (Mbps)'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Taxa de Transferência (Mbps)'
                            }
                        }
                    }
                }
            };
        }

        getAvailabilityConfig() {
            return {
                type: 'doughnut',
                data: {
                    labels: ['Online', 'Offline'],
                    datasets: [{
                        data: [0, 0],
                        backgroundColor: [
                            '#4CAF50',
                            '#F44336'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Disponibilidade das Redes'
                        }
                    }
                }
            };
        }

        getPortsConfig() {
            return {
                type: 'radar',
                data: {
                    labels: ['HTTP (80)', 'HTTPS (443)', 'SSH (22)', 'RDP (3389)', 'DNS (53)'],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Portas Abertas por Rede'
                        }
                    },
                    scales: {
                        r: {
                            angleLines: {
                                display: true
                            },
                            suggestedMin: 0,
                            suggestedMax: 1
                        }
                    }
                }
            };
        }

        initWebSocket() {
            this.socket = new WebSocket(`ws://${window.location.host}/ws/status/`);
            
            this.socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                this.handleMessage(data);
            };

            this.socket.onclose = () => {
                setTimeout(() => this.initWebSocket(), 5000);
            };
        }

        handleMessage(data) {
            switch(data.type) {
                case 'initial_data':
                    this.updateNetworkStatus(data.redes);
                    this.updateIntrusosTable(data.intrusos);
                    this.updateCharts(data.redes);
                    break;
                case 'network_update':
                    this.updateNetworkStatus(data.redes);
                    this.updateCharts(data.redes);
                    break;
                case 'intrusion_alert':
                    this.showIntrusionAlert(data.intruso);
                    break;
                case 'zabbix_data':
                    this.updateZabbixData(data.metrics);
                    break;
                case 'grafana_data':
                    this.updateGrafanaData(data.metrics);
                    break;
            }
        }

        updateNetworkStatus(networks) {
            const container = document.getElementById('network-status');
            container.innerHTML = networks.map(network => `
                <div class="network-card ${network.status ? 'online' : 'offline'}">
                    <h3>${network.nome}</h3>
                    <p>IP: ${network.ip}</p>
                    <p>Status: ${network.status ? 'Online' : 'Offline'}</p>
                    <p>Latência: ${network.latencia || 'N/A'} ms</p>
                    <p>Última verificação: ${new Date(network.ultima_verificacao).toLocaleTimeString()}</p>
                </div>
            `).join('');
            
            // Atualiza dados para os gráficos
            this.networkData = networks.reduce((acc, network) => {
                acc[network.nome] = network;
                return acc;
            }, {});
        }

        updateIntrusosTable(intrusos) {
            const tbody = document.querySelector('#intrusos-table tbody');
            tbody.innerHTML = intrusos.map(intruso => `
                <tr class="${intruso.bloqueado ? 'bloqueado' : 'intruso'}">
                    <td>${intruso.ip_address}</td>
                    <td>${intruso.mac_address || 'Desconhecido'}</td>
                    <td>${new Date(intruso.primeira_deteccao).toLocaleString()}</td>
                    <td>${intruso.tentativas}</td>
                    <td>${intruso.bloqueado ? 'BLOQUEADO' : 'ATIVO'}</td>
                </tr>
            `).join('');
        }

        updateCharts(networks) {
            // Atualiza gráfico de disponibilidade
            const onlineCount = networks.filter(n => n.status).length;
            this.charts.availability.data.datasets[0].data = [
                onlineCount,
                networks.length - onlineCount
            ];
            this.charts.availability.update();
            
            // Atualiza gráfico de portas
            this.updatePortsChart(networks);
        }

        updatePortsChart(networks) {
            const commonPorts = [80, 443, 22, 3389, 53];
            
            this.charts.ports.data.datasets = networks.map(network => {
                const portData = commonPorts.map(port => 
                    network.portas_abertas.includes(port) ? 1 : 0
                );
                
                return {
                    label: network.nome,
                    data: portData,
                    backgroundColor: this.getColorWithOpacity(this.getRandomColor(), 0.2),
                    borderColor: this.getRandomColor(),
                    borderWidth: 1
                };
            });
            
            this.charts.ports.update();
        }

        updateZabbixData(metrics) {
            metrics.forEach(metric => {
                let dataset = this.charts.zabbixLatency.data.datasets.find(d => d.label === metric.host);
                
                if (!dataset) {
                    dataset = {
                        label: metric.host,
                        data: [],
                        borderColor: this.getRandomColor(),
                        backgroundColor: 'rgba(0, 0, 0, 0)',
                        borderWidth: 2,
                        tension: 0.1
                    };
                    this.charts.zabbixLatency.data.datasets.push(dataset);
                }
                
                dataset.data.push({
                    x: Date.now(),
                    y: metric.value
                });
                
                // Mantém apenas os últimos 100 pontos
                if (dataset.data.length > 100) {
                    dataset.data.shift();
                }
            });
            
            this.charts.zabbixLatency.update('quiet');
        }

        updateGrafanaData(metrics) {
            this.charts.grafanaTraffic.data.datasets = metrics.map(metric => ({
                label: metric.host,
                data: [metric.in, metric.out],
                backgroundColor: [
                    this.getColorWithOpacity('#2196F3', 0.5),
                    this.getColorWithOpacity('#FF5722', 0.5)
                ],
                borderColor: [
                    '#2196F3',
                    '#FF5722'
                ],
                borderWidth: 1
            }));
            
            this.charts.grafanaTraffic.update();
        }

        setupZabbixGrafanaIntegration() {
            // Simulação de dados - na prática, você faria requisições para suas APIs
            setInterval(() => {
                // Simula dados do Zabbix
                if (Object.keys(this.networkData).length > 0) {
                    const zabbixData = {
                        type: 'zabbix_data',
                        metrics: Object.values(this.networkData).map(network => ({
                            host: network.nome,
                            value: network.status ? Math.random() * 10 + 5 : 1000
                        }))
                    };
                    this.handleMessage(zabbixData);
                }
                
                // Simula dados do Grafana
                const grafanaData = {
                    type: 'grafana_data',
                    metrics: Object.values(this.networkData).map(network => ({
                        host: network.nome,
                        in: network.status ? Math.random() * 50 + 10 : 0,
                        out: network.status ? Math.random() * 30 + 5 : 0
                    }))
                };
                this.handleMessage(grafanaData);
            }, 5000);
        }

        showIntrusionAlert(intruso) {
            const alert = document.createElement('div');
            alert.className = 'intrusion-alert';
            alert.innerHTML = `
                <h3>INTRUSO DETECTADO!</h3>
                <p>IP: ${intruso.ip_address}</p>
                <p>MAC: ${intruso.mac_address || 'Desconhecido'}</p>
                <p>Tentativas: ${intruso.tentativas}</p>
                <button onclick="this.parentElement.remove()">Fechar</button>
            `;
            document.body.appendChild(alert);
            
            // Toca um alerta sonoro
            new Audio('/static/alert.mp3').play().catch(e => console.log("Não foi possível tocar o alerta:", e));
        }

        getRandomColor() {
            return `hsl(${Math.floor(Math.random() * 360)}, 70%, 50%)`;
        }

        getColorWithOpacity(color, opacity) {
            if (color.startsWith('hsl')) {
                return color.replace(')', `, ${opacity})`).replace('hsl', 'hsla');
            }
            if (color.startsWith('#')) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            return color;
        }
    }

    // Inicializa o monitor quando a página carrega
    document.addEventListener('DOMContentLoaded', () => {
        window.monitor = new NetworkMonitor();
    });
</script>
</body>
</html>